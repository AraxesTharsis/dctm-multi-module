= Introduction =

In an ideal world Documentum development would follow the same pattern as mainstream Enterprise Java development practices where tools such as Maven have become popular in standardising and (arguably) simplifying build and deployment processes. [http://martinfowler.com/articles/continuousIntegration.html Continuous Integration] has also helped in fostering good build practices.

..but Documentum development has always been different ;-/

This project is an experiment in making Documentum development a bit more mainstream.

= Tools for the Job =

== Source Code Repository Server ==
  * [http://subversion.apache.org Subversion Server]

== Nexus Maven Repository Server ==
  * [http://www.java.com Java]
  * [http://tomcat.apache.org Apache Tomcat]
  * [http://maven.apache.org Apache Maven]

== Jenkins Build Server ==
  * [http://www.java.com Java]
  * [http://tomcat.apache.org Apache Tomcat]
  * [http://maven.apache.org Apache Maven]
  * [http://ant.apache.org Apache Ant]
  * [http://subversion.apache.org Subversion Client]
  * [http://nexus.sonatype.org Nexus Maven Repository Manager]
  * [http://www.documentum.com Documentum Headless Composer]

== Developer Workstation ==
  * [http://www.java.com Java]
  * [http://ant.apache.org Apache Ant]
  * [http://maven.apache.org Apache Maven]
  * [http://subversion.apache.org Subversion Client]
  * [http://www.documentum.com Documentum Composer]

Please note that  [http://maven.apache.org/ant-tasks Maven Ant Tasks] are downloaded on demand by the Ant build scripts.

As Nexus and Jenkins are both Java web applications they can be hosted on the same Tomcat instance.

Please refer to the relevant websites for installation details.

= Approach to Development =
Using the setup described in this project it should be possible for developers to work in the following way:

  * checkout source code from source code repository (e.g. Subversion)
  * run `mvn eclipse:eclipse` or `mvn idea:idea` to create IDE project files
  * import projects in IDE
  * use IDE support for Ant to compile, run JUnit tests, etc
  * commit source code to source code repository
  * build server triggers build job from code commit
  * build job generates compiles code, runs JUnit tests, creates JAR, WAR and DAR artifacts
  * build job deploys JAR, WAR and DAR artifacts to Maven repository
  * build job optionally deploys DAR artifacts to Documentum repository
  * post-build Jenkins task deploys WAR to application server

= Build System =
<p>
I tried, and failed, to use a 100% Maven-based approach but the main problem was that Maven only supports the generation of multiple artifacts (e.g. BOF JARs) if you set up 1 POM per artifact. This basically means that you have to set up a shedload of sub-projects if your Documentum solution uses a bunch of !JarDefs (and most projects do). This is impractical. The things that I really like about Maven though were dependency management, standardisation of project structure and standardisation of project goals (or targets in Ant lingo).
</p>
<p>
I like Ant. It's simple and flexible. It can be used for multi-project development with a bit of care but there's no OOTB support for dependency management and there's no standard project structure. But we can add dependency management through the use of Maven Ant tasks and standard project structure is really just a matter of following a convention as you'll see below.
</p>

== Project Structure ==
<p>
The project structure is pretty straightforward. Project will exist under one of the top level folders:
</p>
  * *java-projects*: contains sub-projects that generate JARs
  * *composer-projects*: contains sub-projects that generate DARs
  * *web-projects*: contains sub-projects that generate WARs
<img src="http://dctm-multi-module.googlecode.com/svn/trunk/wiki-images/project-structure.png" />
<p>
The following files exist in the project root:
</p>
  * *build.xml*: master build script used to build all sub-projects
  * *common.properties*: contains properties that are referenced by shared macros and targets
  * *common.xml*: contains shared targets and macros that are used by sub-projects
  * *composer.xml*: contains targets used to build DARs (is referenced by the Jenkins build script)
  * *jenkins-composer-build-script-example.txt*: Example DAR build/deploy script for Jenkins
  *  *README.txt*: Read-me file

=== java-projects ===
<p>
In the below screenshot you can see that we have a single Java project named bof-java. The project structure is based on Maven's standard project structure. All source files exist under `src`. Artifacts such as JARs, JUnit reports and Javadocs are generated under `target`.
</p>
<img src="http://dctm-multi-module.googlecode.com/svn/trunk/wiki-images/java-projects.png" />
<p>
The bof-java project contains the following files and folders:
</p>
  * *build.xml*: This is the project build script
  * *build.properties*: The contains project-specific properties that are referenced by build.xml
  * *pom.xml*: This is a Maven configuration file that defines dependencies that are needed to compile the JARs
<p>
In the pom.xml we declare the Maven repository that we solve JAR dependencies from. In the following snippet you can see that we're referencing a host called buildserver:
</p>
{{{
    <repositories>
        <repository>
            <id>snapshots</id>
            <name>snapshots</name>
            <url>http://buildserver:8080/nexus/content/repositories/snapshots</url>
            <releases>
                <enabled>false</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <updatePolicy>daily</updatePolicy>
            </snapshots>
        </repository>
        <repository>
            <id>releases</id>
            <name>releases</name>
            <url>http://buildserver:8080/nexus/content/repositories/releases</url>
            <releases>
                <enabled>true</enabled>
                <updatePolicy>daily</updatePolicy>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </repositories>
}}}
<p>
We also declare the JAR dependencies here. In the following snippet you can see that we're referencing the DFS SDK:
</p>
{{{
	<dependencies>
	...
        <dependency>
            <groupId>emc.dfs.sdk</groupId>
            <artifactId>emc.dfs.sdk</artifactId>
            <version>6.7.0</version>
            <type>pom</type>
        </dependency>
	...
	</dependencies>
}}}
<p>
We can create IDE project files for Eclipse using the command `mvn eclipse:eclipse`. If you prefer Intelli-J IDEA use `mvn idea:idea`. You can now import the project into the IDE and use the built-in Ant support to build the project. You will find the following Ant targets by running `ant -p`:
</p>
 * *clean*: Cleans any generated artifacts
 * *compile*: Compiles the module java source
 * *deploy*: Deploys the JARs to the remote Maven repository
 * *install*: Installs the JARs to the local Maven repository
 * *javadoc*: Generates Javadoc documentation
 * *package*: Creates the JARs
 * *test*: Runs the JUnit tests
<p>
Please note that the dependencies are automatically added to the classpath. Some of the targets such as `compile` and `clean` are inherited from common.xml. The `package` target creates JARs, some of which we'll use in the bof-java Composer projects and some that we'll use in the Webtop web project.
</p>
{{{
	<target name="package" depends="compile" description="Creates the JARs">
		<echo message="Creating module JARs" />
		<makejar name="numberservice-api.jar" includes="org/markdav/projectx/bof/numberservice/api/**" />
		<makejar name="numberservice-impl.jar" includes="org/markdav/projectx/bof/numberservice/impl/**" />
	</target>
}}}
<p>
The `install` target installs the packaged artifacts to the local Maven repository and the `deploy` target deploys the packaged artifacts to the remote Maven repository. Remember that other projects reference dependencies from Maven repositories so simply packaging the artifact is not sufficient.
</p>
{{{
	<target name="install" depends="package" description="Installs the JARs to the local Maven repository">
	    <echo message="Installing module JARs" />
		<mvninstall file="${target.dir}/numberservice-api.jar"
		            groupId="com.markdav.projectx" artifactId="numberservice-api"
		            version="1.0.0-SNAPSHOT" packaging="jar" uniqueVersion="false" />
		<mvninstall file="${target.dir}/numberservice-impl.jar"
		            groupId="com.markdav.projectx" artifactId="numberservice-impl"
		            version="1.0.0-SNAPSHOT" packaging="jar" uniqueVersion="false" />
	</target>
	
	<target name="deploy" depends="package" description="Deploys the JARs to the remote Maven repository">
	    <echo message="Deploying module JARs" />
		<mvndeploy file="${target.dir}/numberservice-api.jar"
		           groupId="com.markdav.projectx" artifactId="numberservice-api"
		           version="1.0.0-SNAPSHOT" packaging="jar" uniqueVersion="false"
		           url="${mvn.snapshots.url}" repositoryId="${mvn.snapshots.id}" />
		<mvndeploy file="${target.dir}/numberservice-impl.jar"
		           groupId="com.markdav.projectx" artifactId="numberservice-impl"
		           version="1.0.0-SNAPSHOT" packaging="jar" uniqueVersion="false"
		           url="${mvn.snapshots.url}" repositoryId="${mvn.snapshots.id}" />
	</target>
}}}

=== composer-projects ===
<p>
In the below screenshot you can see that we have two Composer projects named projectx-base and projectx-sbo. 
</p>
<img src="http://dctm-multi-module.googlecode.com/svn/trunk/wiki-images/composer-projects.png" />
  * *build.xml*: This is the project build script
  * *pom.xml*: This is a Maven configuration file that defines project dependencies
<p>
The projectx-sbo project is used to deploy SBOs and consequently defines a couple of JarDefs. The JARs that these JarDefs reference are built by the bof-java project. We reference these JARs through dependencies that are defined in pom.xml.
</p>
{{{
	<dependencies>
        <dependency>
        	<groupId>com.markdav.projectx</groupId>
        	<artifactId>numberservice-api</artifactId>
        	<version>1.0.0-SNAPSHOT</version>
        </dependency>
        <dependency>
        	<groupId>com.markdav.projectx</groupId>
        	<artifactId>numberservice-impl</artifactId>
        	<version>1.0.0-SNAPSHOT</version>
        </dependency>
	</dependencies>
}}}
<p>
The ant build script, build.xml, just imports the commons.xml, specifying that the default target is to resolve any dependencies. The Composer project configuration has been modified to invoke a new AntBuilder - i.e. it invokes the build.xml script and therefore fetches the JARs that we need before building the DAR.
<p>
{{{
<project name="projectx-sbo" default="composerdependencies" basedir=".">
	<dirname property="project.dir" file="${ant.file.imported}"/>
	<import file="${project.dir}/../../common.xml" />
</project>
}}}
</p>
We can use the imported targets and `installdar2maven` and `deploydar2maven` to make the DAR available through Maven.
</p>

=== web-projects ===
<p>
In the below screenshot you can see that we have a single WDK project named webtop. 
</p>
<img src="http://dctm-multi-module.googlecode.com/svn/trunk/wiki-images/web-projects.png" />
<p>
The webtop project contains the following files and folders:
</p>
  * *build.xml*: This is the project build script
  * *pom.xml*: This is a Maven configuration file that defines dependencies that are needed to compile the WAR